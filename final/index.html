<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 | Final Project</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>

<body>
  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
  <h1 align="middle">Final Project: Gravitational N-Body Simulator</h1>

  <h2 align="middle">Alex Jean, Ryan Kee, Kevyn Ramirez, Amit</h2>

  <div align="center">
    <table style="width=100%">
        <tr>
            <td align="middle">
            <img src="images/nbodyintro.gif" width="480px" />
        </tr>
    </table>
  </div>

  <div align="center">
    <table style="width=100%">
        <tr>
            <td align="middle">
            <p>embed final video here</p>
        </tr>
    </table>
  </div>
  
  <div class="padded">


    <h2 align="middle">Abstract</h2>

    <p>
      In the 17th century, Sir Isaac Newton, in an attempt to study the orbits of the planets in our solar system, discovered that his equations of motion weren't able to accurately predict the orbits of our celestial bodies. He realized that gravitational forces between all the planets would influence their orbits, and thus the n-body problem was born. The n-body problem is an interesting and complex topic that can be used to study the dynamics of heavenly bodies as well as other particle interactions, such as particles in an electric field. We were inspired by this problem to create a simulator that models the interaction of particles in space under the influence of gravitational forces. 
    </p>
   


    <h2 align="middle">Technical Approach</h2>

    <h3 align="middle">
      Overview</h2>

      <p>
        Our technical approach involves developing a gravity particle simulator that simulates the interactions of particles in a gravitational field. We decided to use Cloth Sim as a skeleton and general architecture for our N-Body Sim because we wanted to make use of the camera, GUI, and renderer methods. To improve the performance when simulating a large number of particles, we used the Barnes-Hut algorithm, which reduces the computational complexity of simulating N-bodies from $O(N^2)$ to $O(N\log{N})$ by grouping particles into an octree. We also added a few new shaders to add visual flair to our particles and improved upon the GUI to add features that allow for dynamically creating different particle configurations, setting simulation speeds, and swapping shaders.
      </p>

      <h3 align="middle">Getting Started: Building off of Cloth Sim</h3>

      <p>
        Our first objective was to understand the Cloth Sim pipeline and GUI / program initialization so we could clone a skeleton version of it. This involved reading clothSimulator.h/cpp and main.cpp to understand how the GUI, renderer, and camera were initialized and being used. Once we had a general understanding, we created a new CMAKE project and copied over the code for any relevant methods, removing unused parameters and objects.

        After we got our project to compile, our next objective was to render a few spheres. In Cloth Sim, we don't render any point masses, only the wireframe that's attached to each Spring. For our purposes, we wanted to render particles as spheres, so we used SphereMesh::draw_sphere(), which would render a sphere of specified position and size with a shader applied to it. This ended up being perfect for our use case, so we created a new Particle class that would call this method when Particle::render(GLShader) was called on it. This allowed us to successfully render a few particles on the GUI.
      </p>

      <h3 align="middle">Simulation: Newton's Laws and Integration Methods</h3>
      <p>
        In each step of our simulate method, we compute the forces on each particle and then update the position and velocity for every particle.
        Interactions between particles in space are determined by Newton's Law of Universal Gravitation, which states:
        <div style="text-align:center">
          $F = G \dfrac{m_1 m_2}{r^2}$
        </div>
        Each particle interacts with every other particle, so if we have $N$ particles, we would have to perform $N(N-1)$ calculations. This works for a small number of particles, but we would need to implement a more effecient solution later.
      </p>
      <p>
        When updating the positions of the particles, we used numerical integration to estimate the position and velocity at the next timestep. Initially, we used Forward Euler, a first-order, explicit numerical integrator, to test if our system could run with a few particles. The Forward Euler update rule is defined as such:
        <div style="text-align:center">
          $x_{t+1} = x_t + v_t \Delta t$, <br />
          $v_{t+1} = v_t + a_t \Delta t$
        </div>
        However, this led to our particles exhibiting very unstable behavior, and it was especially noticible when the particles would have large accelerations from getting too close to massive particles or after a short period of time, all particles would fly off to infinity. This was to be expected, as Forward Euler is numerically unstable, leading to catastrophic errors building up over time. Upon doing further research we found and referenced a paper called <i>"N-Body simulations of gravitational dynamics"</i> by Walter Dehnen and Justin I. Read, where they discussed different integration methods. We chose "Kick-Drift-Kick" Leapfrog Integration, which is second order numerical integrator defined as such:
        <div style="text-align:center">
          $v_{t+{1/2}} = v_t + a_t \dfrac{\Delta t}{2}$, <br />
          $x_{t+1} = x_t + v_{t+{1/2}} \Delta t$, <br />
          $v_{t+1} = v_{t+{1/2}} + a_{t+1} \dfrac{\Delta t}{2} $
        </div>
        KDK Leapfrog computes the updates by using the midpoint velocity to compute the update to the next timestep's position and velocity. This means the velocities are "staggered" with respect to our positions. A special property of leapfrog integration is it's time reversibility, which means we can reverse the velocities and timestep to arrive at an exact solution of a previous timestep. Other integrators such as Euler or Runge-Kutta are only able to arrive at approximate solutions. This time reversibility garauntees conservation of energy over at each timestep when a fixed timestep is used, which allows means our simulation will remain numerically stable over time. 
        <div style="text-align:center">
          <img src="images/kdkleapfrog.PNG" width="480px" />
          <figcaption align="middle">Diagram showing the "leapfrogging" timestep. Figure from "Leapfrog Integration"</figcaption>
        </div>
      </p>
      <h3 align="middle">Improving Performance: Barnes-Hut</h3>
      <p>
        TODO
      </p>

      <h3 align="middle">Improving Usability: Particle Generation and GUI</h3>
      <p>
        TODO
      </p>


      <h3 align="middle">Improving Visuals: Shaders</h3>
      <h4>Cook-Torrance</h4>
      <p>
        During our research, we wanted to find different rendering models compared to those we've seen in lecture.
        This is how we stumbled upon the Cook-Torrance model. The Cook-Torrance model is a microfacet model used
        for simulating the appearnce of rough surfaces. It uses a combination of the surface roughness and the surface
        reflectance to calculate its appearance. It is widely used to simulate metals, plastics, and ceramics, but
        we thought it would be itneresting to try to implement.
      </p>
      <p>
        The equation for the Cook-Torrance model is
      </p>
      <div style="text-align:center">
        $f_r = k_d f_{lambert} +  k_s f_{cook-torrance}$
      </div>
      <p>
        Where $f_{lambert}$ is the diffuse component, and $f_{cook_torrance}$ is the specular component.
        Instead of $k_d$ and $k_s$, we used a single variable $s$ to represent the ratio of light diffused and
        specularly reflected, changing our equation to
      </p>
      <div style="text-align:center">
        $f_r = s f_{lambert} +  (1-s) f_{cook-torrance}$
      </div>
      <p>
        The diffuse component is the same as that of the Phong model: $f_{lambert} = (I/r^2) max(0, n \cdot l) u_{color}$,
        $u_{color}$, which is the color chosen from the GUI, acting as the diffuse coefficient. The specular component, however,
        has the following function as its specular coefficient:
      </p>
      <div style="text-align:center">
        $f_{cook-torrance} = \frac{D * G * F}{4 * (\vec n \cdot \vec l) * (\vec n \cdot \vec v)}$
      </div>
      <p>
        The distribution function $D$ is the part of the Cook-Torrance model that describes the concentration
        of microfacets oriented to reflect specularity. There are many choices of functions that can be used to describe this
        distribution, so we chose to use the Phong distribution to keep results close to something we are famiilar with:
      </p>
      <div style="text-align:center">
        $D_{blinn} = \frac{1}{\pi \alpha^2} (\vec h \cdot \vec n)^{\left( \frac{2}{\alpha^2} - 2 \right)}$
      </div>
      <p>
        Here, $\alpha$ represents the roughness of the object. We used $\alpha = 0.6$ because it gave the best appearance given
        the position of our light source and the distribution of particles.
      </p>
      <p>
        The geometry function $G$ is used to describe the proportion of light that the microfacets do not block by
        either occludding or shadowing each other. Therefore, it is defined as the minimum of two different factors calculating
        either type of attenuation.
      </p>
      <div style="text-align:center">
        $G = min \left( 1, \frac{2 (\vec h \cdot \vec n) (\vec n \cdot \vec v)}{(\vec v \cdot \vec h)}, \frac{2 (\vec h \cdot \vec n) (\vec n \cdot \vec l)}{(\vec v \cdot \vec h)} \right)$
      </div>
      <p>
        Finally, the fresnel function $F$ is used to simulate the way light itneracts with a surface at different angles. The
        equation for $F$ changes depending on whether the material is a dielectric or a conductor. Because a particle wouldn't
        necessarily be a dielectric or conductor type of material, we used Schlick's Approximation, as it allows us to approximate
        the fresnel function considering both materials properties:
      </p>
      <div style="text-align:center">
        $F = F_0 + (1 - F_0)*(1 - (\vec v \cdot \vec h))^5$
      </div>
      <div style="text-align:center">
        $F_0 = \frac{(n - 1)^2}{(n + 1)^2}$
      </div>
      <p>
        Here $F{0}$ is the reflectance at normal incidence, and $n$ is the material's index of refraction. We chose an arbitrary
        $n$ of $n = 1.2$.
      </p>
      <h4>Planet Shaders</h4>
      <p>
        The intention of the Planet shaders were to color the particle by useing noise to randomly sample its surface.
        We used the position of a given particle as the input to our noise function, causing the smaller particle to appear as if they
        had their own spin as they orbits around a large mass in our simulations. While trying various combinations of functions to
        declare the color at a given pixel in the shader, we stumbled upon the result of what can be described as "sun flares"
        on our particles, long stripes across the surface of the particle that seem to merge and diverge from each other seemingly
        at random.
      </p>
      <h2 align="middle">
        Results
      </h2>
    </h3>
        <div style="display: flex; margin: 1rem">
          <div>
            <iframe width="420" height="315" src="https://youtu.be/7bQ3N_84FF0"> </iframe>
            <p>
              Simulation
            </p>
          </div>
        </div>
        <h2 align="middle">References</h2>
          <ul>
            <li><a href="http://www.physics.drexel.edu/~steve/Courses/Comp_Phys/Integrators/leapfrog/">Leapfrog Integration</a></li>
            <li><a href="https://people.eecs.berkeley.edu/~demmel/cs267/lecture26/lecture26.html">Barnes Hut: Berkeley CS 267 - Lecture 24</a></li>
            <li><a href="http://arborjs.org/docs/barnes-hut">Barnes Hut Illustrations</a></li>
            <li><a href=" https://home.ifa.hawaii.edu/users/barnes/ast626_05/nbm.pdf">Barnes Hut, delta term</a></li>
            <li><a href="https://arxiv.org/abs/1105.1082"><i>N-body simulations of gravitational dynamics</i> by Walter Dehnen, Justin Read</a></li>
            <li><a href="https://graphicscompendium.com/gamedev/15-pbr">Physically-Based Rendering Cook-Torrance Reflectance Model</a></li>
            <li><a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx">Physically Based Rendering - Cook-Torrance</a></li>
            <li><a href="http://obermuhlner.ch/wordpress/2014/09/01/using-glsl-shaders-to-generate-planets/">Eric Oberm√ºhlner - Using GLSL Shaders to generate Planets</a></li>
            <li><a href="https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl">GLSL Noise Function</a></li>
          </ul>

          <h2 align="middle"> Contributions</h2>
            <p>
              <ul>
                <li>Alex Jean - </li>
                <li>Ryan Kee - </li>
                <li>Kevyn Ramirez - </li>
                <li>Amit Bhandal - Absolutely Nothing</li>
              </ul>
            </p>

          </h2>

        </h2>

      </h2>

    </h2></div>
</body>
</html>
